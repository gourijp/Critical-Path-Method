<input id="fileInp" type="file"> </input>
<p id="para1"> </p>

<script type="application/javascript" src="jquery-1.12.0.js"> </script>
<script type="application/javascript" src="vis.min.js"></script>
<script type="application/javascript">

    var fileText = "ACTIVITY,DESCRIPTION,PREDECESSOR,DURATION\n" +
            "A,READ,NONE,2\n" +
            "B,MODIFY,A&D,1\n" +
            "C,WRITE,D,6\n"+
            "F,WRITE,C,2\n"+
            "D,WRITE,NONE,5\n"+
            "E,WRITE,B&C,4\n";


var createTaskStoreFunction = function (textData) {

        var schedulingData = [];

        var schedulingTextArray = textData.split("\n");
        var headers = schedulingTextArray[0].split(',');

        for (var k = 1; k < schedulingTextArray.length; k++) {
            schedulingData[k - 1] = schedulingTextArray[k].split(',');
        }
        schedulingData.pop();

        for (var k = 0; k < schedulingData.length; k++){
            var predecessorElement = schedulingData[k][2];
            predecessorElement = predecessorElement.split('&');

            var index = predecessorElement.indexOf("NONE")
            if (index > -1) {
                predecessorElement.splice(index, 1);
            }
            schedulingData[k][2] = predecessorElement;
            schedulingData[k][3] = parseInt(schedulingData[k][3]);
        }

        var taskStore = {};

        for (var i = 0; i < schedulingData.length; i++) {
           var tempObj = {};
            for (var j = 0; j < headers.length; j++) {
                tempObj[headers[j]] = schedulingData[i][j];

            }
            taskStore['task' + schedulingData[i][0]] = tempObj;

        }
        for (var i = 0; i < schedulingData.length; i++) {
            taskStore['task' + schedulingData[i][0]]["PREDECESSOR"] = [];
            taskStore['task' + schedulingData[i][0]]["SUCCESSOR"] = [];
        }

        for (var i = 0; i < schedulingData.length; i++){
            for(j = 0; j<schedulingData[i][2].length; j++) {
                taskStore['task' + schedulingData[i][0]][headers[2]][j] = taskStore['task' + schedulingData[i][2][j]];
                taskStore['task' + schedulingData[i][2][j]]["SUCCESSOR"].push(taskStore['task' + schedulingData[i][0]]);
            }
        }
        return taskStore;
    }


    var subset = function(subset,set){

        for(var i = 0; i<subset.length; i++){
            if(set.indexOf(subset[i]) === -1){
                return false;
            }
        }
        return true;
    }

    var topologicalSort = function(taskStore){
        var topologyArray = [];
        var taskContainerArray = Object.keys(taskStore);

        while(taskContainerArray.length !== topologyArray.length) {
            for (var i = 0; i < taskContainerArray.length; i++) {
                var isSubset = subset(taskStore[taskContainerArray[i]]["PREDECESSOR"], topologyArray);
                if((isSubset === true)&&(topologyArray.indexOf(taskStore[taskContainerArray[i]]) === -1)) {
                    topologyArray.push(taskStore[taskContainerArray[i]]);
                }
            }
        }
        return topologyArray;
    }


    var cpmForwardPassCalc = function(topologyArray){
      for(var i = 0; i<topologyArray.length; i++){

          var precedenceArray = topologyArray[i]["PREDECESSOR"];
          var arrayOfEF = [];

          if(precedenceArray.length === 0){
              topologyArray[i].ES = 0;
              topologyArray[i].EF = topologyArray[i]["DURATION"];
          }
          else {
              for (var j=0; j<precedenceArray.length; j++) {
                  arrayOfEF.push(precedenceArray[j]["EF"]);
              }
                  topologyArray[i].ES = Math.max.apply(Math, arrayOfEF);
                  topologyArray[i].EF = topologyArray[i].ES + topologyArray[i]["DURATION"];
          }
      }
        return topologyArray;
    }



    var cpmBackwardPassCalc = function(forwardPassArray){
        var tempArrayOfEF = [];

        for(var i = forwardPassArray.length - 1; i>=0;  i--) {
            var successorArray = forwardPassArray[i]["SUCCESSOR"];

            if (successorArray.length === 0) {
                tempArrayOfEF.push(forwardPassArray[i].EF);
            }
        }

        for(var i = forwardPassArray.length - 1; i>=0;  i--) {
            successorArray = forwardPassArray[i]["SUCCESSOR"];
            var arrayOfLS = [];

            if (successorArray.length === 0) {
                forwardPassArray[i].LF = Math.max.apply(Math, tempArrayOfEF);
                forwardPassArray[i].LS = forwardPassArray[i].LF - forwardPassArray[i]["DURATION"];
            }
            else{
                for(var j=0; j<successorArray.length; j++){
                    arrayOfLS.push(successorArray[j]["LS"]);
                }
                forwardPassArray[i].LF = Math.min.apply(Math, arrayOfLS);
                forwardPassArray[i].LS = forwardPassArray[i].LF - forwardPassArray[i]["DURATION"];
            }
        }
        return forwardPassArray;
    }



    var slackCalculator = function(CPMParametersArray){

        for(var i = 0; i<CPMParametersArray.length; i++){
           CPMParametersArray[i].Totalfloat = CPMParametersArray[i].LF - CPMParametersArray[i].EF;

            if(CPMParametersArray[i].Totalfloat === 0){
                document.getElementById("para1").innerHTML = document.getElementById("para1").innerHTML + "Task "+ CPMParametersArray[i]["ACTIVITY"] + " is on Critical Path. <br>"
            }
        }
    }



    var CPMCalculator = function(text){
        var taskStoreObject = createTaskStoreFunction(text);
        var arrayOfTopologicallySortedTasks = topologicalSort(taskStoreObject);
        var topologyArrayWithForwardPass = cpmForwardPassCalc(arrayOfTopologicallySortedTasks);
        var topologyArrayWithCPMParameters = cpmBackwardPassCalc(topologyArrayWithForwardPass);
        slackCalculator(topologyArrayWithCPMParameters);
    }

</script>